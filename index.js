const { Telegraf, Markup } = require("telegraf");
const fs = require("fs");
const fetch = require("node-fetch");
const timestampToDate = require("timestamp-to-date");
require("dotenv").config();
const bot = new Telegraf(process.env.BOT_TOKEN);

const subscribersFileName = "subscribers.json";
const outSubscribersFileName = "outsubscribers.json";

const tsApiKey = process.env.TS_TOKEN;
const wallet = "TNFm9JdGoj58wnkos742obF8mN4Xcm5n6X";
const contract_address = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t";
const outWallet = "TXhyDNCzdC5WMUfqtVbi9zwf7vgsMkMmKc";

const interval = 3;
const minAmount = 10000;
const minAmountLow = 3000;

let lastTransferId = "";
let lastTimeStamp = "";

let lastOutId = "";
let lastOutTimeStamp = "";

(async () => {
   while (true) {
      console.log("–ü–æ—Å–ª–µ–¥–Ω–µ–µ ID –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è " + lastTransferId);
      console.log(
         `–ü–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è ${
            lastTimeStamp &&
            timestampToDate(lastTimeStamp, "dd.MM.yyyy HH:mm:ss")
         }`
      );
      await fetch(
         `https://api.trongrid.io/v1/accounts/${wallet}/transactions/trc20?limit=20&contract_address=${contract_address}&min_timestamp=${lastTimeStamp}&only_to=true`
      )
         .then((response) => response.json())
         .then(async (data) => {
            const transfers = data.data;

            if (lastTransferId !== "" && transfers.length > 0) {
               if (lastTransferId !== transfers[0].transaction_id) {
                  let newAmount = null;
                  await fetch(`https://api.trongrid.io/v1/accounts/${wallet}`)
                     .then((response) => response.json())
                     .then(async (data) => {
                        if (data.data.length > 0) {
                           if (data.data[0].trc20.length > 0) {
                              for (let el of data.data[0].trc20) {
                                 for (let token in el) {
                                    if (token === contract_address) {
                                       newAmount = (
                                          el[token] / 1000000
                                       ).toFixed(0);
                                       break;
                                    }
                                 }
                              }
                           }
                        }
                     })
                     .catch(async (error) => {});
                  const subscribers = await JSON.parse(
                     fs.readFileSync(subscribersFileName, { encoding: "utf8" })
                  );
                  let maxI = transfers.length - 1;
                  for (let i = 0; i < transfers.length; i++) {
                     if (transfers[i].transaction_id === lastTransferId) {
                        maxI = i - 1;
                     }
                  }
                  for (let i = maxI; i >= 0; i--) {
                     if (transfers[i].transaction_id !== lastTransferId) {
                        const transferAmount = (
                           transfers[i].value / 1000000
                        ).toFixed(0);
                        if (
                           transferAmount >= minAmount ||
                           (newAmount < minAmount + 10000 &&
                              transferAmount > minAmountLow)
                        ) {
                           for (let subscriber in subscribers) {
                              await bot.telegram.sendMessage(
                                 subscribers[subscriber],
                                 `üî¥üî¥üî¥üî¥üî¥\n–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ: ${transferAmount} USDT\n–í—Ä–µ–º—è: ${timestampToDate(
                                    transfers[i].block_timestamp,
                                    "HH:mm:ss"
                                 )}${
                                    newAmount !== null
                                       ? `\n–ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: ${newAmount} USDT`
                                       : ""
                                 }`
                              );
                              await sleep(100);
                           }
                        }
                     }
                  }
                  lastTransferId = transfers[0].transaction_id;
                  lastTimeStamp = transfers[0].block_timestamp;
						setTimeout(async () => {
							await fetch(
								`https://api.trongrid.io/v1/accounts/${wallet}`
							)
								.then((response) => response.json())
								.then(async (data) => {
									if (data.data.length > 0) {
										if (data.data[0].trc20.length > 0) {
											for (let el of data.data[0].trc20) {
												for (let token in el) {
													if (
														token === contract_address
													) {
														for (let subscriber in subscribers) {
															await bot.telegram.sendMessage(
																subscribers[
																	subscriber
																],
																`–ë–∞–ª–∞–Ω—Å –∫–æ—à–µ–ª—å–∫–∞: ${(
																	el[token] / 1000000
																).toFixed(0)}`
															);
															await sleep(100);
														}
														break;
													}
												}
											}
										}
									}
								})
								.catch(async (error) => {});
						}, 60000);
               }
            } else {
               if (transfers.length > 0) {
                  lastTransferId = transfers[0].transaction_id;
                  lastTimeStamp = transfers[0].block_timestamp;
               }
            }
            if (transfers) {
               for (let i = 0; i < transfers.length; i++) {
                  console.log(`${i + 1}. ${transfers[i].transaction_id}`);
               }
            }
         })
         .catch((error) => console.error(error));
      await sleep(500);
      console.log(" ");

      console.log("–ü–æ—Å–ª–µ–¥–Ω–µ–µ ID –≤—ã–≤–æ–¥–∞ " + lastOutId);
      console.log(
         `–ü–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –≤—ã–≤–æ–¥–∞ ${
            lastOutTimeStamp &&
            timestampToDate(lastOutTimeStamp, "dd.MM.yyyy HH:mm:ss")
         }`
      );
      await fetch(
         `https://api.trongrid.io/v1/accounts/${outWallet}/transactions/trc20?limit=20&contract_address=${contract_address}&min_timestamp=${lastOutTimeStamp}&only_to=true`
      )
         .then((response) => response.json())
         .then(async (data) => {
            const outs = data.data;
            if (lastOutId !== "" && outs.length > 0) {
               if (lastOutId !== outs[0].transaction_id) {
                  const outSubscribers = await JSON.parse(
                     fs.readFileSync(outSubscribersFileName, {
                        encoding: "utf8",
                     })
                  );
                  let maxI = outs.length - 1;
                  for (let i = 0; i < outs.length; i++) {
                     if (outs[i].transaction_id === lastOutId) {
                        maxI = i - 1;
                     }
                  }
                  for (let i = maxI; i >= 0; i--) {
                     if (
                        outs[i].transaction_id !== lastOutId &&
                        outs[i].from === wallet
                     ) {
                        for (let subscriber in outSubscribers) {
                           await bot.telegram.sendMessage(
                              outSubscribers[subscriber],
                              `–ù–æ–≤—ã–π –≤—ã–≤–æ–¥\n–°—É–º–º–∞: ${(
                                 outs[i].value / 1000000
                              ).toFixed(1)}\n–î–∞—Ç–∞: ${timestampToDate(
                                 outs[i].block_timestamp,
                                 "HH:mm:ss dd.MM.yyyy"
                              )}\n–ö–æ—à–µ–ª–µ–∫: ${outs[i].to.slice(0, 4)}***${outs[
                                 i
                              ].to.slice(-4)}`
                           );
                           await sleep(100);
                        }
                     }
                  }
                  lastOutId = outs[0].transaction_id;
                  lastOutTimeStamp = outs[0].block_timestamp;
               }
            } else {
               if (outs.length > 0) {
                  lastOutId = outs[0].transaction_id;
                  lastOutTimeStamp = outs[0].block_timestamp;
               }
            }
            if (outs) {
               for (let i = 0; i < outs.length; i++) {
                  console.log(`${i + 1}. ${outs[i].transaction_id}`);
               }
            }
         })
         .catch((error) => console.error(error));
      await sleep(interval * 1000);
      console.log("----------------------------------------------------------");
   }
})();

bot.on("message", async (ctx) => {
   if (!ctx.message.text) return;
   if (ctx.message.text.trim() === "/balance") {
      fetch(`https://api.trongrid.io/v1/accounts/${wallet}`)
         .then((response) => response.json())
         .then(async (data) => {
            if (data.data.length > 0) {
               if (data.data[0].trc20.length > 0) {
                  let findUsdt = false;
                  for (let el of data.data[0].trc20) {
                     for (let token in el) {
                        if (token === contract_address) {
                           await ctx.reply(
                              `–ë–∞–ª–∞–Ω—Å –∫–æ—à–µ–ª—å–∫–∞: ${(el[token] / 1000000).toFixed(
                                 0
                              )} USDT`
                           );
                           findUsdt = true;
                           break;
                        }
                     }
                  }
                  if (!findUsdt) {
                     await ctx.reply("USDT –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
                  }
               } else {
                  await ctx.reply("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞");
               }
            } else {
               await ctx.reply("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞");
            }
         })
         .catch(async (error) => await ctx.reply("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫"));
   } else if (ctx.message.text.trim() === "/sub") {
      const chatId = ctx.message.chat.id;
      let data = JSON.parse(
         fs.readFileSync(subscribersFileName, { encoding: "utf8" })
      );
      if (chatId in data) {
         await ctx.reply("–í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É");
      } else {
         data[chatId] = chatId;
         fs.writeFileSync(subscribersFileName, JSON.stringify(data), {
            encoding: "utf8",
            flag: "w",
         });
         const newData = JSON.parse(
            fs.readFileSync(subscribersFileName, { encoding: "utf8" })
         );
         if (chatId in newData) {
            await ctx.reply("–í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É");
         } else {
            await ctx.reply("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫");
         }
      }
   } else if (ctx.message.text.trim() === "/unsub") {
      const chatId = ctx.message.chat.id;
      const data = JSON.parse(
         fs.readFileSync(subscribersFileName, { encoding: "utf8" })
      );
      if (chatId in data) {
         delete data[chatId];
         fs.writeFileSync(subscribersFileName, JSON.stringify(data), {
            encoding: "utf8",
            flag: "w",
         });
         const newData = JSON.parse(
            fs.readFileSync(subscribersFileName, { encoding: "utf8" })
         );
         if (chatId in newData) {
            await ctx.reply("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫");
         } else {
            await ctx.reply("–í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —Ä–∞—Å—Å—ã–ª–∫–∏");
         }
      } else {
         await ctx.reply("–í—ã –µ—â—ë –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É");
      }
   } else if (ctx.message.text.trim() === "/outsub") {
      const chatId = ctx.message.chat.id;
      let data = JSON.parse(
         fs.readFileSync(outSubscribersFileName, { encoding: "utf8" })
      );
      if (chatId in data) {
         await ctx.reply("–í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É –≤—ã–≤–æ–¥–æ–≤");
      } else {
         data[chatId] = chatId;
         fs.writeFileSync(outSubscribersFileName, JSON.stringify(data), {
            encoding: "utf8",
            flag: "w",
         });
         const newData = JSON.parse(
            fs.readFileSync(outSubscribersFileName, { encoding: "utf8" })
         );
         if (chatId in newData) {
            await ctx.reply("–í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É –≤—ã–≤–æ–¥–æ–≤");
         } else {
            await ctx.reply("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫");
         }
      }
   } else if (ctx.message.text.trim() === "/outunsub") {
      const chatId = ctx.message.chat.id;
      const data = JSON.parse(
         fs.readFileSync(outSubscribersFileName, { encoding: "utf8" })
      );
      if (chatId in data) {
         delete data[chatId];
         fs.writeFileSync(outSubscribersFileName, JSON.stringify(data), {
            encoding: "utf8",
            flag: "w",
         });
         const newData = JSON.parse(
            fs.readFileSync(outSubscribersFileName, { encoding: "utf8" })
         );
         if (chatId in newData) {
            await ctx.reply("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫");
         } else {
            await ctx.reply("–í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —Ä–∞—Å—Å—ã–ª–∫–∏ –≤—ã–≤–æ–¥–æ–≤");
         }
      } else {
         await ctx.reply("–í—ã –µ—â—ë –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É –≤—ã–≤–æ–¥–æ–≤");
      }
   } else if (ctx.message.text.trim() === "/out") {
      fetch(
         `https://api.trongrid.io/v1/accounts/${outWallet}/transactions/trc20?limit=20&contract_address=${contract_address}&only_to=true`
      )
         .then((response) => response.json())
         .then(async (data) => {
            const transfers = data.data;
            if (transfers.length > 0) {
               let message = "";
               for (let transfer of transfers) {
                  if (transfer.from === wallet) {
                     message += `${(transfer.value / 1000000).toFixed(
                        1
                     )} USDT ${timestampToDate(
                        transfer.block_timestamp,
                        "HH:mm:ss dd.MM.yyyy"
                     )}\n`;
                  }
               }
               await ctx.reply(message);
            } else await ctx.reply("–í—ã–≤–æ–¥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
         })
         .catch(async (error) => await ctx.reply("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫"));
   }
});
bot.launch();

function sleep(ms) {
   return new Promise((resolve) => setTimeout(resolve, ms));
}

// Enable graceful stop
process.once("SIGINT", () => bot.stop("SIGINT"));
process.once("SIGTERM", () => bot.stop("SIGTERM"));
